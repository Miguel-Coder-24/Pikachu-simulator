--- INICIO DEL PROYECTO ---


========================================
FILE: index.html
========================================
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pikachu Simulator</title>
    <link rel="stylesheet" href="./styles/main.css">
</head>
<body>
    <header>
        <div>
            <h1>Simulador de Red Nacional (Escala Grande)</h1>
            <div class="subtitle">Topolog√≠a mallada din√°mica</div>
        </div>
        <div id="clock">T = 0.0s</div>
    </header>

    <div id="main-container">
        <div id="canvas-container">
            <canvas id="grid-canvas"></canvas>
            <div id="status-overlay">
                Sistema estable<br>
                Zoom autom√°tico.<br>
                Arrastra nodos para reorganizar.
            </div>
        </div>

        <aside id="sidebar">
            <div class="panel">
                <h3>Controles Globales</h3>
                <button id="btn-peak" class="primary">‚ö° Pico Nacional (+20%)</button>
                <button id="btn-trip" class="danger">üé≤ Falla Aleatoria de L√≠nea</button>
                <button id="btn-reset">üîÑ Regenerar Topolog√≠a</button>
            </div>

            <div class="panel">
                <h3>M√©tricas en Tiempo Real</h3>
                <div id="system-metrics" class="metrics">Calculando...</div>
            </div>

            <div class="panel">
                <h3>Top 5 L√≠neas Cr√≠ticas</h3>
                <div id="lines-status"></div>
            </div>

            <div class="panel panel-console">
                <h3>Registro de Eventos</h3>
                <div id="log-console"></div>
            </div>
        </aside>
    </div>

    <script type="module" src="./src/main.js"></script>
</body>
</html>



========================================
FILE: src/config.js
========================================
export const CONFIG = {
    // Metadatos
    VERSION: '0.2.0 (High Voltage)',
    SEED_SAMPLE: true,

    // Mundo virtual donde se renderiza Colombia
    WORLD_WIDTH: 2000,
    WORLD_HEIGHT: 2500,

    // Configuraci√≥n visual
    GRID_SIZE: 40,
    BACKGROUND_COLOR: '#0a0a0f',
    GRID_LINE_COLOR: '#1a1a25',
    
    COLORS: {
        // Generadores
        SOURCE: '#FFD700',
        SOURCE_GLOW: '#FFC107',

        // Cargas
        LOAD: '#00E5FF',
        LOAD_GLOW: '#00B8D4',

        // L√≠neas
        LINE_OFF: '#2c2c3a',
        LINE_NORMAL: '#FFD700',
        LINE_CRITICAL: '#FF3D00',

        // Accento de grilla
        GRID_ACCENT: '#233042'
    },

    // UI
    UI: {
        SIDEBAR_WIDTH: 320,
        CONSOLE_HEIGHT: 200
    },

    // Modo depuraci√≥n
    DEBUG_MODE: true
};



========================================
FILE: src/core/AssetLoader.js
========================================
// src/core/AssetLoader.js

// Iconos SVG Base64 (Ya los ten√≠as, los mantenemos igual)
const ICONS = {
    load: 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI2NCIgaGVpZ2h0PSI2NCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9IiMwMEU1RkYiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIj48cGF0aCBkPSJNMyA5bDktNyA5IDd2MTFhMiAyIDAgMCAxLTIgMkg1YTIgMiAwIDAgMS0yLTJ6Ij48L3BhdGg+PHBvbHlsaW5lIHBvaW50cz0iOSAyMiA5IDEyIDE1IDEyIDE1IDIyIj48L3BvbHlsaW5lPjwvc3ZnPg==',
    gen: 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI2NCIgaGVpZ2h0PSI2NCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9IiNGRkQ3MDAiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIj48cGF0aCBkPSJNMTMgMkwwIDE0aDEybDMgOUwyNCAxMGgtMTJ6Ii8+PC9zdmc+'
};

// URL de datos abiertos con el contorno de Colombia de alta precisi√≥n
const GEOJSON_URL = 'https://raw.githubusercontent.com/johan/world.geo.json/master/countries/COL.geo.json';

export class AssetLoader {
    constructor() {
        this.assets = {};
        this.mapData = null; // Aqu√≠ guardaremos el GeoJSON
    }

    async loadAll() {
        console.log("üîÑ Cargando recursos...");

        // 1. Cargar Im√°genes
        const imagePromises = Object.entries(ICONS).map(([key, src]) => {
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = () => { this.assets[key] = img; resolve(); };
                img.onerror = () => { console.warn(`Fallo icono ${key}`); resolve(); };
                img.src = src;
            });
        });

        // 2. Cargar Mapa GeoJSON (Fetch)
        const mapPromise = fetch(GEOJSON_URL)
            .then(response => response.json())
            .then(data => {
                this.mapData = data;
                console.log("üó∫Ô∏è Mapa de Colombia de alta precisi√≥n descargado.");
            })
            .catch(err => {
                console.error("Error descargando mapa:", err);
                this.mapData = null; // Fallback a nulo si no hay internet
            });

        await Promise.all([...imagePromises, mapPromise]);
        
        return { images: this.assets, mapGeoJSON: this.mapData };
    }
}


========================================
FILE: src/core/GameLoop.js
========================================
export class GameLoop {
    constructor(updateCallback) {
        this.updateCallback = updateCallback;
        this.lastTime = 0;
        this.isRunning = false;
        this.frameId = null;
    }

    start() {
        if (this.isRunning) return;
        this.isRunning = true;
        this.lastTime = performance.now();
        this.loop(this.lastTime);
    }

    stop() {
        this.isRunning = false;
        if (this.frameId) cancelAnimationFrame(this.frameId);
    }

    loop(currentTime) {
        if (!this.isRunning) return;

        // Calcular delta (tiempo que pas√≥ desde el √∫ltimo frame)
        const deltaTime = (currentTime - this.lastTime) / 1000; // en segundos
        this.lastTime = currentTime;

        // Ejecutar la l√≥gica del juego
        this.updateCallback(deltaTime);

        // Pedir el siguiente frame
        this.frameId = requestAnimationFrame((t) => this.loop(t));
    }
}


========================================
FILE: src/core/PowerGridSimulation.js
========================================
import { PowerNode } from './PowerNode.js';
import { TransmissionLine } from './TransmissionLine.js';
import { CONFIG } from '../config.js';
import { REAL_NODES_DATA } from '../data/colombia_outline.js';

export class PowerGridSimulation {
    constructor(renderer, logger, ui) {
        this.renderer = renderer;
        this.logger = logger;
        this.ui = ui;

        this.nodes = [];
        this.lines = [];
        this.currentTime = 0;
        this.timeStep = 0.05;
        this.accumulator = 0;
        
        // Bounding Box de Colombia
        this.geoBounds = {
            minLon: -82.0, maxLon: -66.0,
            minLat: -4.5,  maxLat: 13.5
        };
    }

    // --- CORRECCI√ìN CLAVE ---
    // Ya no usamos width/height de la pantalla. Usamos el WORLD_WIDTH/HEIGHT fijo.
    projectToWorld(lat, lon) {
        const xPct = (lon - this.geoBounds.minLon) / (this.geoBounds.maxLon - this.geoBounds.minLon);
        const yPct = (this.geoBounds.maxLat - lat) / (this.geoBounds.maxLat - this.geoBounds.minLat);

        return {
            x: xPct * CONFIG.WORLD_WIDTH,
            y: yPct * CONFIG.WORLD_HEIGHT
        };
    }

    resetGrid() {
        // Nota: Ya no necesitamos recibir canvasWidth/Height aqu√≠
        this.currentTime = 0;
        this.nodes = [];
        this.lines = [];
        this.accumulator = 0;

        this.logger.log('üåê Cargando Topolog√≠a Nacional Georreferenciada...', 'info');

        // 1. Crear Nodos Reales proyectados al Mundo Virtual
        REAL_NODES_DATA.forEach(data => {
            const coords = this.projectToWorld(data.lat, data.lon);
            
            const node = new PowerNode(data.id, data.name, data.type, coords.x, coords.y);
            
            if (data.type === 'gen') node.pGen = data.mw;
            else node.pLoad = data.mw / 10;

            this.nodes.push(node);
        });

        // 2. Conexi√≥n Autom√°tica (Vecinos cercanos)
        this.nodes.forEach((nodeA) => {
            const neighbors = this.nodes
                .filter(n => n !== nodeA)
                .map(n => ({
                    node: n,
                    dist: Math.hypot(nodeA.x - n.x, nodeA.y - n.y)
                }))
                .sort((a, b) => a.dist - b.dist)
                .slice(0, 2); // Conectar con los 2 m√°s cercanos

            neighbors.forEach(({ node: nodeB }) => {
                const exists = this.lines.find(l => 
                    (l.from === nodeA && l.to === nodeB) || 
                    (l.from === nodeB && l.to === nodeA)
                );
                if (!exists) {
                    const id = `L-${this.lines.length + 1}`;
                    this.lines.push(new TransmissionLine(id, nodeA, nodeB));
                }
            });
        });

        this.logger.log(`Mapa cargado: ${this.nodes.length} activos. Coordenadas sincronizadas.`, 'success');
        this.solvePowerFlow();
        this.updateUI();
    }

    // ... Resto de m√©todos (solvePowerFlow, triggerPeakLoad, etc) IGUALES ...
    solvePowerFlow() {
        let totalLoad = 0;
        let totalGenCapacity = 0;
        this.nodes.forEach(n => {
            if (n.type === 'load') totalLoad += n.pLoad;
            if (n.type === 'gen') totalGenCapacity += n.pGen;
        });
        const systemStress = Math.min(1.5, totalLoad / Math.max(1, totalGenCapacity));
        this.nodes.forEach(n => {
            if (n.type === 'gen') {
                n.currentGen = n.pGen * systemStress;
                n.netPower = n.currentGen;
            } else {
                n.netPower = -n.pLoad;
            }
            n.vVirtual = 1.0 + (n.netPower / 2000);
        });
        this.lines.forEach(line => {
            if (!line.status) {
                line.currentLoadMva = 0;
                return;
            }
            const vDiff = line.from.vVirtual - line.to.vVirtual;
            const flow = (vDiff / line.impedance) * 10;
            const loadPull = line.to.type === 'load' ? line.to.pLoad : 0;
            line.currentLoadMva = Math.abs(flow) + (loadPull * 0.4);
        });
        this.updateUI(totalLoad, totalGenCapacity, systemStress);
    }

    triggerPeakLoad() {
        this.nodes.forEach(n => { if (n.type === 'load') { n.pLoad *= 1.2; n.radius += 3; } });
        this.logger.log('ALERTA: Pico de demanda (+20%)', 'warn');
        setTimeout(() => {
            this.nodes.filter(n => n.type === 'load').forEach(n => n.radius -= 3);
            this.solvePowerFlow();
        }, 300);
    }

    tripRandomLine() {
        const active = this.lines.filter(l => l.status);
        if (!active.length) return;
        const randomLine = active[Math.floor(Math.random() * active.length)];
        randomLine.status = false;
        this.logger.log(`FALLA: L√≠nea ${randomLine.id} fuera de servicio.`, 'error');
        this.solvePowerFlow();
    }

    cutLine(line) {
        if (!line || !line.status) return;
        line.status = false; 
        this.logger.log(`MANUAL: Corte de l√≠nea ${line.id}`, 'warn');
        this.solvePowerFlow();
        this.updateUI();
    }

    update(deltaTime) {
        this.accumulator += deltaTime;
        while (this.accumulator >= this.timeStep) {
            this.currentTime += this.timeStep;
            this.solvePowerFlow();
            this.lines.forEach(line => {
                const tripped = line.updateThermal(this.timeStep);
                if (tripped && line.status) {
                    line.status = false;
                    this.logger.log(`PROTECCI√ìN: ${line.id} disparo t√©rmico!`, 'error');
                }
            });
            this.updateUI();
            this.accumulator -= this.timeStep;
        }
    }

    updateUI(totalLoad, totalGenCapacity, systemStress) {
        if (this.ui.clock) this.ui.clock.textContent = `T = ${this.currentTime.toFixed(1)}s`;
        const load = totalLoad ?? this.nodes.filter(n => n.type === 'load').reduce((a, n) => a + n.pLoad, 0);
        const gen = totalGenCapacity ?? this.nodes.filter(n => n.type === 'gen').reduce((a, n) => a + n.pGen, 0);
        const stress = systemStress ?? Math.min(1.5, load / Math.max(1, gen));
        if (this.ui.metrics) {
            this.ui.metrics.innerHTML = `Demanda Total: <strong>${load.toFixed(0)} MW</strong><br>Generaci√≥n Activa: ${(gen * stress).toFixed(0)} MW<br>Estr√©s Red: <span style="color:${stress > 1 ? 'red' : CONFIG.COLORS.SOURCE}">${(stress * 100).toFixed(0)}%</span>`;
        }
        if (this.ui.linesStatus) {
            const critical = this.lines.filter(l => l.status && l.currentLoadMva > 0).sort((a, b) => (b.currentLoadMva / b.capacityMva) - (a.currentLoadMva / a.capacityMva)).slice(0, 5);
            let html = '<table style="width:100%; font-size:0.75rem;">';
            critical.forEach(l => {
                const pct = ((l.currentLoadMva / l.capacityMva) * 100).toFixed(0);
                const color = pct > 90 ? '#ff5252' : '#4CAF50';
                html += `<tr style="color:${color}"><td>${l.id}</td><td>${pct}%</td></tr>`;
            });
            html += '</table>';
            this.ui.linesStatus.innerHTML = html;
        }
        if (this.ui.overlay) this.ui.overlay.textContent = stress > 1 ? 'Alerta: Sobrecarga detectada' : 'Sistema estable';
    }
}


========================================
FILE: src/core/PowerNode.js
========================================
export class PowerNode {
    constructor(id, name, type, x, y) {
        this.id = id;
        this.name = name;
        this.type = type; // 'gen' o 'load'
        this.x = x;
        this.y = y;

        // Estado el√©ctrico y potencia
        this.voltageKv = 230;
        this.pGen = 0;
        this.pLoad = 0;
        this.netPower = 0;
        this.currentGen = 0;
        this.vVirtual = 1.0;

        // Visuales
        this.radius = type === 'gen' ? 18 : 10;
        this.color = type === 'gen' ? '#4CAF50' : '#FF5252';
        this.dragging = false;
    }
}



========================================
FILE: src/core/TransmissionLine.js
========================================
export class TransmissionLine {
    constructor(id, fromNode, toNode) {
        this.id = id;
        this.from = fromNode;
        this.to = toNode;

        const dist = Math.hypot(fromNode.x - toNode.x, fromNode.y - toNode.y);

        this.capacityMva = 350;
        this.impedance = Math.max(0.01, dist / 1000);

        this.status = true;
        this.currentLoadMva = 0;
        this.thermalLoad = 0;
        this.thermalThreshold = 100;
        this.thermalK = 8.0;
    }

    updateThermal(dt) {
        if (!this.status) {
            this.thermalLoad = 0;
            return false;
        }

        const loadPct = (this.currentLoadMva / this.capacityMva) * 100;
        const overloadRatio = Math.max(0, loadPct / 95 - 1.0);

        if (overloadRatio > 0) {
            this.thermalLoad += (overloadRatio * 10) * this.thermalK * dt;
        } else {
            this.thermalLoad *= Math.exp(-dt * 0.5);
        }

        return this.thermalLoad >= this.thermalThreshold;
    }
}



========================================
FILE: src/core/camara.js
========================================
// src/core/Camera.js

export class Camera {
    constructor(canvasWidth, canvasHeight) {
        this.x = 0;      // Desplazamiento X (Pan)
        this.y = 0;      // Desplazamiento Y (Pan)
        this.zoom = 1;   // Nivel de Zoom
        
        // Configuraci√≥n inicial para centrar Colombia aprox
        this.width = canvasWidth;
        this.height = canvasHeight;
    }

    // Convierte coordenada de Pantalla (Mouse) a Mundo (Simulaci√≥n)
    screenToWorld(screenX, screenY) {
        return {
            x: (screenX - this.x) / this.zoom,
            y: (screenY - this.y) / this.zoom
        };
    }

    // Convierte coordenada de Mundo a Pantalla (Para dibujar)
    worldToScreen(worldX, worldY) {
        return {
            x: (worldX * this.zoom) + this.x,
            y: (worldY * this.zoom) + this.y
        };
    }

    // Manejar Zoom (Rueda del mouse)
    handleZoom(delta, mouseX, mouseY) {
        const zoomIntensity = 0.1;
        const oldZoom = this.zoom;
        
        // Calcular nuevo zoom
        if (delta < 0) this.zoom *= (1 + zoomIntensity);
        else this.zoom *= (1 - zoomIntensity);

        // Limites de zoom
        this.zoom = Math.max(0.5, Math.min(this.zoom, 10));

        // Ajustar Pan (x,y) para hacer zoom hacia donde est√° el mouse
        this.x = mouseX - (mouseX - this.x) * (this.zoom / oldZoom);
        this.y = mouseY - (mouseY - this.y) * (this.zoom / oldZoom);
    }

    // Manejar Pan (Arrastrar clic derecho/rueda)
    handlePan(dx, dy) {
        this.x += dx;
        this.y += dy;
    }
}


========================================
FILE: src/data/colombia_outline.js
========================================
// src/data/colombia_outline.js

// Contorno simplificado de Colombia (Longitud, Latitud)
export const COLOMBIA_OUTLINE = [
    [-71.7, 12.5], [-71.1, 11.8], [-72.1, 11.5], [-72.9, 11.3], 
    [-74.8, 11.1], [-75.3, 10.3], [-76.4, 9.4], [-77.0, 8.5],
    [-77.4, 7.2],  [-77.9, 6.5],  [-77.4, 5.0], [-77.5, 4.0],
    [-78.5, 2.5],  [-79.0, 1.6],  [-78.8, 1.2], [-76.0, 0.5],
    [-75.2, -0.1], [-74.0, -2.0], [-72.0, -3.0], [-70.0, -4.2],
    [-69.4, -1.0], [-67.8, 1.5],  [-67.4, 4.0],  [-67.5, 6.1],
    [-70.5, 6.5],  [-71.0, 7.0],  [-72.0, 8.5],  [-72.5, 9.5],
    [-73.0, 10.5], [-71.7, 12.5]
];

// Nodos Reales
export const REAL_NODES_DATA = [
    { id: 'GEN-01', name: 'Hidroituango', type: 'gen', lat: 7.13, lon: -75.64, mw: 2400 },
    { id: 'GEN-02', name: 'Guavio',       type: 'gen', lat: 4.69, lon: -73.50, mw: 1200 },
    { id: 'LOAD-01', name: 'Bogot√°',       type: 'load', lat: 4.61, lon: -74.08, mw: 2000 },
    { id: 'LOAD-02', name: 'Medell√≠n',     type: 'load', lat: 6.24, lon: -75.56, mw: 1500 },
    { id: 'LOAD-03', name: 'Cali',         type: 'load', lat: 3.45, lon: -76.53, mw: 1200 },
    { id: 'LOAD-04', name: 'Barranquilla', type: 'load', lat: 10.96, lon: -74.80, mw: 1100 },
    { id: 'LOAD-05', name: 'Bucaramanga',  type: 'load', lat: 7.11, lon: -73.12, mw: 800 }
];


========================================
FILE: src/main.js
========================================
// src/main.js

import { CONFIG } from './config.js';

// --- CORE (L√≥gica) ---
import { PowerGridSimulation } from './core/PowerGridSimulation.js';
import { GameLoop } from './core/GameLoop.js';
import { AssetLoader } from './core/AssetLoader.js'; 

// ... imports ...
import { Camera } from './core/Camera.js'; // Nuevo

const init = async () => {
    // ...
    const assets = await assetLoader.loadAll();

    // 1. Crear C√°mara
    const camera = new Camera(canvas.width, canvas.height);

    // 2. Pasar c√°mara al Renderer
    const renderer = new CanvasRenderer(canvas, assets, camera); // OJO: assets ahora tiene {images, mapGeoJSON}
    
    const logger = new LogConsole(logContainer);
    
    // 3. Simulation necesita ajustar su proyecci√≥n para coincidir con el Renderer
    const simulation = new PowerGridSimulation(renderer, logger, { metrics, linesStatus, overlay, clock });
    
    // 4. Interactions necesita la c√°mara para calcular clics
    const controls = new Interactions(canvas, simulation, camera);
    
    // ...
// --- UI (Presentaci√≥n) ---
// Estos est√°n directamente en /ui/
import { CanvasRenderer } from './ui/CanvasRenderer.js'; 
import { Interactions } from './ui/Interactions.js';

// --- HUD (Interfaz de Usuario sobre el canvas) ---
// Estos est√°n dentro de /ui/hud/ seg√∫n me indicaste
import { SidebarUI } from './ui/hud/Sidebar.js';
import { LogConsole } from './ui/hud/Console.js';

// Funci√≥n de inicializaci√≥n principal
const init = async () => {
    console.log(`‚ö° Iniciando Pikachu-Simulator v${CONFIG.VERSION}...`);

    // 1. Referencias al DOM
    const canvas = document.getElementById('grid-canvas');
    const logContainer = document.getElementById('log-console');
    
    // Elementos de la UI (aseg√∫rate de que existan en tu index.html)
    const metrics = document.getElementById('system-metrics');
    const linesStatus = document.getElementById('lines-status');
    const overlay = document.getElementById('status-overlay');
    const clock = document.getElementById('clock');

    // Validaci√≥n b√°sica
    if (!canvas || !logContainer) {
        console.error("‚ùå Error Cr√≠tico: No se encontraron los elementos base del DOM (canvas o consola).");
        return;
    }

    // Ajustar canvas al tama√±o del contenedor
    const resizeCanvas = () => {
        const container = document.getElementById('canvas-container');
        if (!container) return;
        canvas.width = container.clientWidth;
        canvas.height = container.clientHeight;
    };
    resizeCanvas();

    // 2. Cargar Im√°genes (Assets)
    // Esto es vital para que no falle el renderizado de iconos
    const assetLoader = new AssetLoader();
    const assets = await assetLoader.loadAll();

    // 3. Inicializar Componentes del Sistema
    
    // Renderer: Se encarga de pintar en el canvas
    const renderer = new CanvasRenderer(canvas, assets);
    
    // Logger: Maneja los mensajes en la consola visual
    const logger = new LogConsole(logContainer);
    
    // Simulation: El cerebro del sistema (contiene nodos y l√≥gica el√©ctrica)
    const simulation = new PowerGridSimulation(renderer, logger, { metrics, linesStatus, overlay, clock });
    
    // Controls: Maneja el mouse (arrastrar y cortar)
    const controls = new Interactions(canvas, simulation);
    
    // Sidebar: Botones laterales
    const sidebar = new SidebarUI(simulation);

    // --- CONEXI√ìN CLAVE PARA LA TIJERA ---
    // Le pasamos los controles al sidebar para que el bot√≥n "Cortar" pueda cambiar el modo del mouse
    sidebar.setControls(controls); 

    // 4. Iniciar L√≥gica
    // Generamos la red inicial
    simulation.resetGrid(canvas.width, canvas.height);
    
    // Iniciamos los escuchas de eventos (clics, movimiento mouse)
    controls.initListeners();
    sidebar.init();
    
    logger.log('Sistema en l√≠nea. Listo para operaci√≥n.', 'success');

    // 5. Bucle de Juego (60 FPS aprox)
    const gameLoop = new GameLoop((deltaTime) => {
        simulation.update(deltaTime);
        renderer.render(simulation);
    });

    gameLoop.start();

    // Manejar redimensionado de ventana para que el canvas no se deforme
    window.addEventListener('resize', () => {
        resizeCanvas();
        simulation.resetGrid(canvas.width, canvas.height);
    });
};

// Esperar a que el HTML cargue completo antes de iniciar
window.addEventListener('DOMContentLoaded', init);


========================================
FILE: src/ui/CanvasRenderer.js
========================================
import { CONFIG } from '../config.js';
// Importamos el contorno simple como respaldo por si falla el GeoJSON
import { COLOMBIA_OUTLINE } from '../data/colombia_outline.js';

export class CanvasRenderer {
    constructor(canvas, assets, camera) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        
        this.assets = assets.images;
        this.mapData = assets.mapGeoJSON; 
        
        this.camera = camera;
        
        // Coincide con PowerGridSimulation
        this.geoBounds = { 
            minLon: -82.0, maxLon: -66.0, 
            minLat: -4.5,  maxLat: 13.5 
        };
    }

    // --- PROYECCI√ìN UNIFICADA ---
    project(lat, lon) {
        const xPct = (lon - this.geoBounds.minLon) / (this.geoBounds.maxLon - this.geoBounds.minLon);
        const yPct = (this.geoBounds.maxLat - lat) / (this.geoBounds.maxLat - this.geoBounds.minLat);

        return {
            x: xPct * CONFIG.WORLD_WIDTH,
            y: yPct * CONFIG.WORLD_HEIGHT
        };
    }

    render(simulation) {
        this.clear();

        this.ctx.save();
        // Aplicar C√°mara
        this.ctx.translate(this.camera.x, this.camera.y);
        this.ctx.scale(this.camera.zoom, this.camera.zoom);

        // Dibujar Mundo
        this.drawMapLayer();
        this.drawGrid();
        this.drawLines(simulation.lines);
        this.drawNodes(simulation.nodes);

        this.ctx.restore();
    }

    clear() {
        const { width, height } = this.canvas;
        this.ctx.fillStyle = CONFIG.BACKGROUND_COLOR;
        this.ctx.fillRect(0, 0, width, height);
    }

    drawMapLayer() {
        // Opci√≥n A: Intentar dibujar GeoJSON (Alta calidad)
        if (this.mapData) {
            this.drawGeoJSON();
        } 
        // Opci√≥n B: Fallback a contorno simple (Si fall√≥ la descarga)
        else {
            this.drawSimpleOutline();
        }
    }

    drawGeoJSON() {
        this.ctx.beginPath();
        this.mapData.features.forEach(feature => {
            const geometry = feature.geometry;
            if (geometry.type === 'Polygon') {
                this.drawPolygonPath(geometry.coordinates);
            } else if (geometry.type === 'MultiPolygon') {
                geometry.coordinates.forEach(poly => this.drawPolygonPath(poly));
            }
        });
        this.styleMap();
    }

    drawSimpleOutline() {
        if (!COLOMBIA_OUTLINE) return;
        this.ctx.beginPath();
        // COLOMBIA_OUTLINE es un array simple de coords [lon, lat]
        COLOMBIA_OUTLINE.forEach((coord, i) => {
            const p = this.project(coord[1], coord[0]); // lat, lon
            if (i === 0) this.ctx.moveTo(p.x, p.y);
            else this.ctx.lineTo(p.x, p.y);
        });
        this.ctx.closePath();
        this.styleMap();
    }

    drawPolygonPath(coordinates) {
        const ring = coordinates[0]; 
        ring.forEach((coord, i) => {
            const [lon, lat] = coord;
            const p = this.project(lat, lon);
            if (i === 0) this.ctx.moveTo(p.x, p.y);
            else this.ctx.lineTo(p.x, p.y);
        });
    }

    styleMap() {
        this.ctx.fillStyle = 'rgba(0, 40, 50, 0.3)'; 
        this.ctx.fill();
        this.ctx.lineWidth = 1.5 / this.camera.zoom; 
        this.ctx.strokeStyle = 'rgba(0, 229, 255, 0.3)';
        this.ctx.stroke();
    }

    drawLines(lines) {
        const baseWidth = Math.max(0.5, 2 / this.camera.zoom);

        // Cables fondo
        lines.forEach(line => {
            const { from, to, status } = line;
            this.ctx.beginPath();
            this.ctx.moveTo(from.x, from.y);
            this.ctx.lineTo(to.x, to.y);
            this.ctx.lineWidth = status ? baseWidth : baseWidth * 0.5;
            this.ctx.strokeStyle = status ? '#333' : '#222';
            if (!status) this.ctx.setLineDash([5 / this.camera.zoom, 5 / this.camera.zoom]);
            else this.ctx.setLineDash([]);
            this.ctx.stroke();
        });

        // Energ√≠a
        this.ctx.setLineDash([]);
        this.ctx.lineCap = 'round';
        const time = Date.now() / 1000;

        lines.forEach(line => {
            if (!line.status) return;
            const loadPct = line.currentLoadMva / line.capacityMva;
            let color = CONFIG.COLORS.LINE_NORMAL;
            let speed = 1;
            if (loadPct > 1.0) { color = CONFIG.COLORS.LINE_CRITICAL; speed = 3.0; } 
            else { speed = 0.5 + (loadPct * 2.5); }

            this.ctx.shadowBlur = 10;
            this.ctx.shadowColor = color;
            this.ctx.strokeStyle = color;
            this.ctx.lineWidth = baseWidth;

            const dx = line.to.x - line.from.x;
            const dy = line.to.y - line.from.y;
            const dist = Math.hypot(dx, dy);
            const numParticles = Math.max(1, Math.floor(dist / 100)); 
            const rayLength = 20 / this.camera.zoom;

            for (let i = 0; i < numParticles; i++) {
                const offset = i / numParticles;
                let t = (time * speed + offset) % 1;
                const headX = line.from.x + dx * t;
                const headY = line.from.y + dy * t;
                const tailX = headX - (dx / dist) * rayLength;
                const tailY = headY - (dy / dist) * rayLength;

                this.ctx.beginPath();
                this.ctx.moveTo(tailX, tailY);
                this.ctx.lineTo(headX, headY);
                this.ctx.stroke();
            }
        });
        this.ctx.shadowBlur = 0;
        this.ctx.lineCap = 'butt';
    }

    drawNodes(nodes) {
        const invScale = 1 / this.camera.zoom;
        const iconSize = 32; 

        nodes.forEach(node => {
            const isGen = node.type === 'gen';
            const img = isGen ? this.assets.gen : this.assets.load;
            
            if (!img) return; 

            this.ctx.save();
            this.ctx.translate(node.x, node.y);
            this.ctx.scale(invScale, invScale);

            if (isGen) {
                const pulse = 1 + Math.sin(Date.now() / 300) * 0.1;
                this.ctx.scale(pulse, pulse);
            }

            this.ctx.shadowBlur = 15;
            this.ctx.shadowColor = node.glowColor;
            this.ctx.drawImage(img, -iconSize/2, -iconSize/2, iconSize, iconSize);

            this.ctx.font = 'bold 12px Consolas';
            this.ctx.fillStyle = '#fff';
            this.ctx.textAlign = 'center';
            this.ctx.shadowBlur = 4;
            this.ctx.shadowColor = '#000';
            this.ctx.fillText(node.name, 0, iconSize/2 + 12);

            this.ctx.restore();
        });
    }

    drawGrid() {
        if (this.camera.zoom < 0.8) return; 
        const step = 200; 
        this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.03)';
        this.ctx.lineWidth = 1 / this.camera.zoom;
        this.ctx.beginPath();
        for (let x = 0; x <= CONFIG.WORLD_WIDTH; x += step) {
            this.ctx.moveTo(x, 0);
            this.ctx.lineTo(x, CONFIG.WORLD_HEIGHT);
        }
        for (let y = 0; y <= CONFIG.WORLD_HEIGHT; y += step) {
            this.ctx.moveTo(0, y);
            this.ctx.lineTo(CONFIG.WORLD_WIDTH, y);
        }
        this.ctx.stroke();
    }
}


========================================
FILE: src/ui/Interactions.js
========================================
export class Interactions {
    constructor(canvas, simulation, camera) {
        this.canvas = canvas;
        this.simulation = simulation;
        this.camera = camera; // Referencia a la c√°mara
        
        this.dragNode = null;
        this.mode = 'normal';
        
        // Variables para el Paneo (Mover mapa)
        this.isPanning = false;
        this.lastMouse = { x: 0, y: 0 };
    }

    initListeners() {
        // Desactivar men√∫ contextual (clic derecho) para usarlo para mover el mapa
        this.canvas.addEventListener('contextmenu', e => e.preventDefault());
        
        this.canvas.addEventListener('mousedown', (e) => this.onMouseDown(e));
        this.canvas.addEventListener('mousemove', (e) => this.onMouseMove(e));
        window.addEventListener('mouseup', () => this.onMouseUp());
        
        // Escuchar rueda del mouse (Zoom)
        this.canvas.addEventListener('wheel', (e) => this.onWheel(e), { passive: false });
    }

    setMode(mode) {
        this.mode = mode;
        this.canvas.style.cursor = mode === 'cut' ? 'crosshair' : 'default';
    }

    // Transformar coordenadas del mouse usando la c√°mara
    getMouseWorldPos(e) {
        const rect = this.canvas.getBoundingClientRect();
        const screenX = e.clientX - rect.left;
        const screenY = e.clientY - rect.top;
        return this.camera.screenToWorld(screenX, screenY);
    }

    onMouseDown(e) {
        const worldPos = this.getMouseWorldPos(e);

        // Clic Derecho o Rueda: Iniciar Paneo
        if (e.button === 2 || e.button === 1) {
            this.isPanning = true;
            this.lastMouse = { x: e.clientX, y: e.clientY };
            this.canvas.style.cursor = 'grabbing';
            return;
        }

        if (this.mode === 'cut') {
            const line = this.findLineAt(worldPos.x, worldPos.y);
            if (line) this.simulation.cutLine(line);
        } else {
            this.dragNode = this.findNodeAt(worldPos.x, worldPos.y);
        }
    }

    onMouseMove(e) {
        // 1. Manejar Paneo (Mover mapa)
        if (this.isPanning) {
            const dx = e.clientX - this.lastMouse.x;
            const dy = e.clientY - this.lastMouse.y;
            this.camera.handlePan(dx, dy);
            this.lastMouse = { x: e.clientX, y: e.clientY };
            return;
        }

        // 2. Manejar Arrastre de Nodos
        if (this.dragNode) {
            const worldPos = this.getMouseWorldPos(e);
            this.dragNode.x = worldPos.x;
            this.dragNode.y = worldPos.y;
            this.simulation.solvePowerFlow();
        }
    }

    onMouseUp() {
        this.isPanning = false;
        this.dragNode = null;
        this.canvas.style.cursor = this.mode === 'cut' ? 'crosshair' : 'default';
    }

    onWheel(e) {
        e.preventDefault();
        const rect = this.canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        
        // Zoom hacia el mouse
        this.camera.handleZoom(e.deltaY, mouseX, mouseY);
    }

    // Helpers (Ahora buscan usando coordenadas mundiales)
    findNodeAt(x, y) {
        // Ajustamos radio de clic inversamente al zoom para facilitar selecci√≥n
        const hitRadius = (this.simulation.nodes[0]?.radius || 20) / this.camera.zoom * 1.5;
        return this.simulation.nodes.find(n => Math.hypot(x - n.x, y - n.y) < hitRadius);
    }

    findLineAt(x, y) {
        const threshold = 10 / this.camera.zoom; // Umbral ajustado al zoom
        return this.simulation.lines.find(line => {
            if (!line.status) return false;
            // (Tu funci√≥n distToSegment va aqu√≠, la omit√≠ por brevedad pero √∫sala igual que antes)
            // ...
            return true; // (Placeholder)
        });
    }
}


========================================
FILE: src/ui/hud/Console.js
========================================
export class LogConsole {
    constructor(container) {
        this.container = container;
    }

    log(message, type = 'info') {
        if (!this.container) return;
        const entry = document.createElement('div');
        entry.className = `log-entry log-${type}`;
        entry.innerText = message;
        this.container.prepend(entry);
    }
}



========================================
FILE: src/ui/hud/Sidebar.js
========================================
// src/ui/hud/Sidebar.js

export class SidebarUI {
    constructor(simulation) {
        this.simulation = simulation;
        // Necesitamos acceso a los controles (Interactions) para cambiar el modo
        // Lo asignaremos en el main.js
        this.controls = null; 
    }

    setControls(controls) {
        this.controls = controls;
    }

    init() {
        const btnPeak = document.getElementById('btn-peak');
        const btnTrip = document.getElementById('btn-trip');
        const btnReset = document.getElementById('btn-reset');

        // Referencia al contenedor de controles globales
        const panel = document.querySelector('.panel'); 

        // 1. Crear bot√≥n de Tijeras din√°micamente
        const btnCut = document.createElement('button');
        btnCut.innerHTML = '‚úÇÔ∏è Cortar L√≠neas';
        btnCut.style.marginTop = '10px';
        btnCut.style.border = '1px solid #FF3D00';
        
        // Insertarlo despu√©s de los otros botones
        panel.appendChild(btnCut);

        // --- Listeners ---

        if (btnPeak) btnPeak.addEventListener('click', () => this.simulation.triggerPeakLoad());
        
        if (btnTrip) btnTrip.addEventListener('click', () => this.simulation.tripRandomLine());
        
        if (btnReset) btnReset.addEventListener('click', () => {
            const canvas = document.getElementById('grid-canvas');
            this.simulation.resetGrid(canvas?.width, canvas?.height);
        });

        // L√≥gica del bot√≥n Tijeras (Toggle)
        btnCut.addEventListener('click', () => {
            if (!this.controls) return;

            if (this.controls.mode === 'normal') {
                this.controls.setMode('cut');
                btnCut.classList.add('active-tool');
                btnCut.innerHTML = '‚úÇÔ∏è MODO CORTE ACTIVO';
            } else {
                this.controls.setMode('normal');
                btnCut.classList.remove('active-tool');
                btnCut.innerHTML = '‚úÇÔ∏è Cortar L√≠neas';
            }
        });
    }
}


========================================
FILE: styles/main.css
========================================
:root {
    --bg-color: #050508;
    --panel-bg: rgba(20, 20, 30, 0.85); /* Semitransparente */
    --panel-border: 1px solid rgba(255, 215, 0, 0.15); /* Borde sutil amarillo */
    --text-color: #e0e0e0;
    --accent-color: #FFD700; /* Amarillo el√©ctrico */
    --accent-hover: #FFEA00;
    --danger-color: #FF3D00;
    --grid-accent: #233042;
    --font-ui: 'Segoe UI', Roboto, Helvetica, sans-serif;
    --font-mono: 'Consolas', 'Monaco', monospace;
}

* { box-sizing: border-box; }

body {
    margin: 0;
    font-family: var(--font-ui);
    background-color: var(--bg-color);
    color: var(--text-color);
    display: flex;
    flex-direction: column;
    height: 100vh;
    overflow: hidden;
}

/* Header Cyberpunk */
header {
    background-color: #0b0b10;
    padding: 10px 20px;
    border-bottom: 1px solid #333;
    display: flex;
    justify-content: space-between;
    align-items: center;
    box-shadow: 0 0 15px rgba(0,0,0,0.5);
    z-index: 20;
}

h1 { 
    margin: 0; 
    font-size: 1.2rem; 
    text-transform: uppercase; 
    letter-spacing: 1px;
    color: var(--accent-color);
    text-shadow: 0 0 10px rgba(255, 215, 0, 0.3);
}

.subtitle { font-size: 0.75rem; color: #889; letter-spacing: 0.5px; }

#clock {
    font-family: var(--font-mono);
    color: var(--accent-color);
    border: 1px solid #333;
    padding: 4px 10px;
    border-radius: 4px;
    background: #000;
}

#main-container {
    display: flex;
    flex: 1;
    position: relative;
    min-height: 0;
}

#canvas-container {
    flex: 1;
    position: relative;
    /* Un gradiente sutil para dar profundidad */
    background: radial-gradient(circle at center, #1a1a20 0%, #050508 100%);
    overflow: hidden;
}

#grid-canvas {
    display: block;
    width: 100%;
    height: 100%;
}

/* UI Overlay Flotante */
#status-overlay {
    position: absolute;
    top: 20px;
    left: 20px;
    pointer-events: none;
    color: rgba(255,255,255,0.7);
    font-size: 0.8rem;
    font-family: var(--font-mono);
    background: rgba(0,0,0,0.6);
    padding: 10px;
    border-radius: 4px;
    border-left: 2px solid var(--accent-color);
    backdrop-filter: blur(4px);
}

/* Barra Lateral Estilo Cristal */
#sidebar {
    width: 340px;
    background-color: var(--panel-bg);
    backdrop-filter: blur(10px); /* Efecto vidrio */
    padding: 20px;
    border-left: 1px solid #333;
    display: flex;
    flex-direction: column;
    gap: 20px;
    z-index: 10;
    overflow-y: auto;
}

.panel {
    background: rgba(255,255,255,0.03);
    padding: 15px;
    border-radius: 8px;
    border: var(--panel-border);
    box-shadow: 0 4px 6px rgba(0,0,0,0.2);
}

.panel h3 { 
    margin-top: 0; 
    font-size: 0.8rem; 
    text-transform: uppercase;
    color: #889;
    border-bottom: 1px solid #333; 
    padding-bottom: 8px; 
    margin-bottom: 12px;
}

/* Botones High-Tech */
button {
    background: linear-gradient(180deg, #333, #222);
    color: #ddd;
    border: 1px solid #444;
    padding: 10px 12px;
    border-radius: 4px;
    cursor: pointer;
    width: 100%;
    margin-bottom: 8px;
    font-size: 0.85rem;
    transition: all 0.2s;
    text-align: center;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

button:hover { 
    background: #444; 
    border-color: #666;
    transform: translateY(-1px);
}

button:active { transform: translateY(1px); }

button.primary { 
    background: linear-gradient(180deg, #FFD700, #FFC107);
    color: #000;
    border: none;
    font-weight: bold;
    box-shadow: 0 0 10px rgba(255, 215, 0, 0.2);
}

button.primary:hover {
    box-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
}

button.danger { 
    background: linear-gradient(180deg, #D32F2F, #B71C1C);
    color: white;
    border: none;
}

button.danger:hover {
    box-shadow: 0 0 10px rgba(255, 61, 0, 0.4);
}

/* Consola y Datos */
.metrics { font-family: var(--font-mono); font-size: 0.85rem; line-height: 1.8; }

#log-console {
    flex: 1;
    background: #000;
    border: 1px solid #333;
    font-family: var(--font-mono);
    font-size: 0.7rem;
    padding: 10px;
    overflow-y: auto;
    border-radius: 4px;
    color: #0f0;
    max-height: 180px;
}

/* Scrollbar personalizada */
::-webkit-scrollbar { width: 6px; }
::-webkit-scrollbar-track { background: #111; }
::-webkit-scrollbar-thumb { background: #444; border-radius: 3px; }
::-webkit-scrollbar-thumb:hover { background: #666; }

/* Cursor personalizado de Tijeras */
.cursor-cut {
    /* Tijeras en SVG Base64 */
    cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="%23FF3D00" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="6" cy="6" r="3"/><circle cx="6" cy="18" r="3"/><line x1="20" y1="4" x2="8.12" y2="15.88"/><line x1="14.47" y1="14.48" x2="20" y2="20"/><line x1="8.12" y1="8.12" x2="12" y2="12"/></svg>') 16 16, auto;
}

/* Estilo para el bot√≥n activo en el sidebar */
button.active-tool {
    background: #FF3D00; /* Rojo intenso */
    color: white;
    box-shadow: 0 0 10px #FF3D00;
    border: 1px solid #fff;
}

